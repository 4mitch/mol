# $mol_viewer

Базовый класс для всех визуальных компонент. Обеспечивает инфраструктуру для ленивого реактивного рендеринга, обработку исключительных ситуаций.

## view.tree

*view.tree* - декларативный язык описания компонент, основанный на [формате tree](https://github.com/nin-jin/tree.d). В одном файле может быть последовательно определено сколько угодно компонент, но лучше каждую компоненту помещать в отдельный файл, кроме совсем уж тривиальных случаев.

Чтобы создать новую компоненту достаточно отнаследовать её от любой уже существующей. Имена компонент должны начинаться с символа `$` и быть глобально уникальными в соответствии с принципами [PMS](https://github.com/nin-jin/pms). Например, объявим компоненту `$my_button` как наследника от `$mol_viewer`:

```tree
$my_button $mol_viewer
```

При наследовании есть возможность объявлять дополнительные свойства или перегружать уже существующие (при этом типы свойств должны совпадать). Например, перегрузим свойство `uri` строкой `"https://example.org"`, а `childs` - массивом из одной строки `"Click me!"`, кроме того, объявляем новое свойство `target` со значением `"_top"` по умолчанию (важно отметить, что значение по умолчанию обязательно при объявлении свойств):

```
$my_exampler $mol_linker
	uri \https://example.org
	childs /
		\Click me!
	target \_top
```

Узлы, начинающиеся на `-` - игнорируются, что позволяет использовать их для комментирования и временного выключения поддерева. Начинающиеся на `$` - имена компонент. `/` - так опозначаются списки. `\` - предваряет сырые данные, которые до конца строки могут содержать совершенно любые символы. Числа, булевы значения и `null` пишутся как есть, без каких либо префиксов:

```
$my_numbers $mol_viewer
	childs /
		0
		1.1
		true
		false
		null
		\I can contain any character! \("o")/
		- I
			am
				remark...
```

Словари (соответствия ключей значениям) можно объявлять через узел `*`, через который задаются, например, значения для атрибутов DOM-элемента:

```
$my_number $mol_viewer
	tagName \input
	attr *
		type \number
		- attribute values must be a strings
		min \0
		max \20
```

Аналогичным образом можно задавать значения для полей DOM-элемента:

```
$my_wonder $mol_viewer
	tagName \input
	field *
		value \Hello!
		style.transform \rotate( 180deg )
```

В качестве значений мы можем брать не только константы, но и содержимое других свойств через одностороннее связывание. Например, объявим два текстовых совйства `hint` и `text`, а потом воспользуемся ими для формирования словаря `field` и списка `childs`:

```
$my_hint $mol_viewer
	hint \Default hint
	text \Default text
	field *
		title < hint 
	childs /
		< text
```

Зачастую удобно совмещать объявление свойства и его использование. следующий пример полностью эквивалентен предыдущему:

```
$my_hint $mol_viewer
	field *
		title < hint \Default hint 
	childs /
		< text \Default text
```

Реакции на DOM-события уже требуют двустороннее связывание. Например, укажем, что объекты события `click` необходимо помещать в свойство eventRemove, которое мы тут же объявили задав значением по умолчанию `null`:

```
$my_remover $mol_viewer
	event *
		click > eventRemove null 
	childs /
		\Remove
```

Непосредственным значением свойства можно объявить экземпляр другого класса. В следующем примере у нас объявляется свойство `lister`, значением которого будет являться компонента типа `$mol_lister_demo`, а потом она помещается в список дочерних комонент `childs`:

```
$my_app $mol_viewer
	lister $mol_lister_demo
	childs /
		< lister
```

У вложенных компонент также можно перегружать любое их свойство:

```
$my_name $mol_viewer
	childs /
		< info $mol_labeler
			title \Name
			content \Jin
```

Свойства родительской и дочерней компоненты можно связывать. В следующем примере мы объявляем изменяемое свойство `name`, дочерней компоненте `input` говорим использовать наше свойство `name` в качестве своего свойства `value`, а компоненте `output` указываем выводить внутри себя значение `name`. Таким образом компоненты `input` и `output` становятся связаны через свойство родителя `name`  и изменение значения в `input` приводит к обновлению output:

```
$my_greeter $mol_viewer
	- ">" allows pushing to property
	> name \
	childs /
		< input $mol_stringer
			hint \Name
			value > name
		< output $mol_viewer
			childs /
				< name
```

Бывают такие свойства, которые в зависимости от ключа возвращают разные значения. Типичный пример - строки списка. Каждая строка - отдельный компонент, доступный по уникальному ключу. Для объявления таких свойств используется суффикс `#`:

```
$my_tasks $mol_lister
	childs < taskRows /
	taskRow# $mol_viewer
	 	childs / < taskTitle#
	taskTitle# < defaultTitle \
```

Тут мы объявили свойтсво `taskRow`, которое принимает на вход некоторый ключ и возвращает для каждого ключа уникальный экземпляр `$mol_viewer`, у которого перегружено свойство `childs`, которое выводит для каждого `taskRow`, соответствующий ему `taskTitle`, а вот `taskTitle` независимо от ключа возвращает по умолчанию содержимое своства `defaultTitle`, которое изначатльно равно пустой строке. В дальнейшем, перегружая любое из этих свойств, мы можем менять любой аспект поведения компонента.
